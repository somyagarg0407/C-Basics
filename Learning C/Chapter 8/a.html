<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #video-container { position: absolute; bottom: 20px; left: 20px; width: 200px; height: 150px; z-index: 2; border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; overflow: hidden; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 3; pointer-events: none; }
        h1 { font-size: 1.2rem; margin: 0 0 5px 0; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 0.9rem; color: #aaa; margin: 0; }
        .instruction { color: #00ffcc; font-weight: bold; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui">
        <h1>Particle Morpher</h1>
        <p>üñê Move hand to Rotate | <span class="instruction">üëå Pinch to Change Shape</span></p>
        <p>Current Shape: <span id="shape-name">Sphere</span></p>
    </div>

    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <div id="container"></div>

<script>
    /**
     * CONFIGURATION & STATE
     */
    const PARTICLE_COUNT = 15000;
    const GESTURE_THRESHOLD = 0.05; // Sensitivity for pinch
    let currentShapeIndex = 0;
    let isPinching = false;
    let particlesData = []; // Stores target positions
    
    // Interaction State
    const mouse = new THREE.Vector2();
    const targetRotation = new THREE.Vector2();
    let explosionFactor = 0;
    
    /**
     * THREE.JS SETUP
     */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.001);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    // Particle Geometry
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const sizes = new Float32Array(PARTICLE_COUNT);

    const colorObj = new THREE.Color();

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        colorObj.setHSL(Math.random(), 0.7, 0.5);
        colors[i * 3] = colorObj.r;
        colors[i * 3 + 1] = colorObj.g;
        colors[i * 3 + 2] = colorObj.b;

        sizes[i] = Math.random() * 2;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    // Custom Shader Material for glowy dots
    const material = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    /**
     * SHAPE GENERATORS
     */
    function getSpherePoint() {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = 20;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    function getHeartPoint() {
        // Parametric Heart
        const t = Math.random() * Math.PI * 2;
        const u = Math.random() * Math.PI; // slice
        const r = 1.2; 
        
        // Complex heart formula approx
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        const z = (Math.random() - 0.5) * 10; // Thickness
        return { x: x*r, y: y*r, z: z };
    }

    function getSaturnPoint() {
        const r = Math.random();
        // 70% Planet, 30% Rings
        if (r > 0.3) {
            // Planet
            const pt = getSpherePoint();
            return { x: pt.x * 0.8, y: pt.y * 0.8, z: pt.z * 0.8 };
        } else {
            // Rings
            const angle = Math.random() * Math.PI * 2;
            const dist = 25 + Math.random() * 15;
            return {
                x: Math.cos(angle) * dist,
                y: (Math.random() - 0.5) * 2, // Flat rings
                z: Math.sin(angle) * dist
            };
        }
    }

    function getFlowerPoint() {
        const u = Math.random() * Math.PI * 2; // Angle
        const v = Math.random() * Math.PI; 
        const rBase = 20;
        // Modulate radius with sine waves to create petals
        const r = rBase + 10 * Math.sin(5 * u) * Math.sin(v); 
        
        return {
            x: r * Math.sin(v) * Math.cos(u),
            y: r * Math.sin(v) * Math.sin(u),
            z: r * Math.cos(v)
        };
    }

    // Pre-calculate shapes
    const shapes = [
        { name: "Sphere", func: getSpherePoint },
        { name: "Heart", func: getHeartPoint },
        { name: "Saturn", func: getSaturnPoint },
        { name: "Flower", func: getFlowerPoint }
    ];

    // Initialize Targets
    let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    
    function setShape(index) {
        const shape = shapes[index];
        document.getElementById('shape-name').innerText = shape.name;
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const pt = shape.func();
            targetPositions[i*3] = pt.x;
            targetPositions[i*3+1] = pt.y;
            targetPositions[i*3+2] = pt.z;
        }
    }
    
    // Start with sphere
    setShape(0);

    /**
     * MEDIAPIPE HAND TRACKING
     */
    const videoElement = document.getElementById('input_video');
    
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. ROTATION: Use Index Finger Tip (Landmark 8) relative to center
            const indexX = landmarks[8].x; 
            const indexY = landmarks[8].y;
            
            // Map 0..1 to -1..1
            targetRotation.x = (indexY - 0.5) * 4; 
            targetRotation.y = (indexX - 0.5) * 4;

            // 2. PINCH DETECTION: Distance between Thumb (4) and Index (8)
            const thumb = landmarks[4];
            const index = landmarks[8];
            const distance = Math.sqrt(
                Math.pow(thumb.x - index.x, 2) + 
                Math.pow(thumb.y - index.y, 2)
            );

            // Pinch Logic (Toggle Shape)
            if (distance < GESTURE_THRESHOLD) {
                if (!isPinching) {
                    isPinching = true;
                    // Switch to next shape
                    currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                    setShape(currentShapeIndex);
                    
                    // Burst effect on change
                    explosionFactor = 2.0;
                }
            } else {
                isPinching = false;
            }

            // 3. EXPANSION: Use wrist depth or general hand size approximation
            // Using distance between wrist(0) and middle finger(12) as proxy for "closeness" to camera
            const wrist = landmarks[0];
            const middle = landmarks[12];
            const handSize = Math.sqrt(Math.pow(wrist.x - middle.x, 2) + Math.pow(wrist.y - middle.y, 2));
            
            // If hand is huge (close to camera), explode particles
            if(handSize > 0.4) {
                 explosionFactor += 0.05;
            }
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    /**
     * ANIMATION LOOP
     */
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // Smooth Rotation
        particles.rotation.x += (targetRotation.x - particles.rotation.x) * 0.05;
        particles.rotation.y += (targetRotation.y - particles.rotation.y) * 0.05;

        // Particle Physics (Morphing)
        const positionsAttribute = geometry.attributes.position;
        const currentPositions = positionsAttribute.array;
        
        // Dampen explosion factor back to 0
        explosionFactor *= 0.95;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // Target coordinates
            const tx = targetPositions[ix];
            const ty = targetPositions[iy];
            const tz = targetPositions[iz];

            // Linear Interpolation (Lerp) towards target
            // Speed varies slightly per particle for organic feel
            const speed = 0.05 + (Math.sin(i) * 0.02); 

            currentPositions[ix] += (tx - currentPositions[ix]) * speed;
            currentPositions[iy] += (ty - currentPositions[iy]) * speed;
            currentPositions[iz] += (tz - currentPositions[iz]) * speed;

            // Add Noise / Float
            currentPositions[ix] += Math.sin(time + i) * 0.02;
            currentPositions[iy] += Math.cos(time + i * 0.5) * 0.02;

            // Add Explosion/Expansion effect based on hand gestures
            if(explosionFactor > 0.01) {
                const dirX = currentPositions[ix];
                const dirY = currentPositions[iy];
                const dirZ = currentPositions[iz];
                
                currentPositions[ix] += dirX * explosionFactor * 0.1;
                currentPositions[iy] += dirY * explosionFactor * 0.1;
                currentPositions[iz] += dirZ * explosionFactor * 0.1;
            }
        }
        
        // Color Cycling based on shape
        const colorsAttr = geometry.attributes.color;
        if(explosionFactor > 0.5) {
             // Flash white/bright on transition
             for(let i=0; i<PARTICLE_COUNT*3; i++) colorsAttr.array[i] = 1;
        } else {
             // Slowly return to base colors (simplified for perf)
             // In a full app we would lerp colors too
        }

        positionsAttribute.needsUpdate = true;
        colorsAttr.needsUpdate = true;
        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>